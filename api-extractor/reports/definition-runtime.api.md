## API Report File for "@scale-codec/definition-runtime"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Decode } from '@scale-codec/core';
import { Encode } from '@scale-codec/core';
import { Enum } from '@scale-codec/core';
import { EnumDef } from '@scale-codec/core';
import { EnumGenericDef } from '@scale-codec/core';
import { Fmt } from 'fmt-subs';
import { Option as Option_2 } from '@scale-codec/core';
import { Result } from '@scale-codec/core';
import { Walker } from '@scale-codec/core';

// @public (undocumented)
export type ArrayItemBuilder<T> = T extends Fragment<infer V, infer U>[] ? FragmentBuilder<V, U> : never;

// @public (undocumented)
export const Bool: FragmentBuilder<boolean, boolean>;

// @public (undocumented)
export function buildDecodeTraceStepsFmt(trace: DecodeTrace, walker: Walker): Fmt;

// @public (undocumented)
export type BuilderFromFragment<T extends Fragment<any>> = T extends Fragment<infer V, infer U> ? FragmentBuilder<V, U> : never;

// @public (undocumented)
export const BytesVec: FragmentBuilder<Uint8Array, Uint8Array>;

// @public
export interface CodecTracker {
    decode?: TrackDecodeFn;
    refineDecodeLoc?: RefineDecodeLocFn;
}

// @public (undocumented)
export const Compact: FragmentBuilder<bigint, bigint>;

// @public (undocumented)
export function createArrayBuilder<T extends Fragment<any>[]>(name: string, itemBuilder: ArrayItemBuilder<T>, len: number): ScaleArrayBuilder<T>;

// @public
export function createBuilder<T, U = T>(name: string, encode: Encode<T>, decode: Decode<T>, unwrap?: FragmentUnwrapFn<T, U>, wrap?: FragmentWrapFn<T, U>): FragmentBuilder<T, U>;

// @public (undocumented)
export function createBytesArrayBuilder(name: string, len: number): FragmentBuilder<Uint8Array>;

// @public (undocumented)
export function createEnumBuilder<T extends ScaleEnum>(name: string, schema: EnumBuilderSchema<EnumDef<T>>): ScaleEnumBuilder<T>;

// Warning: (ae-forgotten-export) The symbol "MapKeyInner" needs to be exported by the entry point lib.d.ts
// Warning: (ae-forgotten-export) The symbol "MapValueInner" needs to be exported by the entry point lib.d.ts
//
// @public (undocumented)
export function createMapBuilder<T extends Map<Fragment<any>, Fragment<any>>>(name: string, keyBuilder: FragmentBuilder<MapKeyInner<T>>, valueBuilder: FragmentBuilder<MapValueInner<T>>): ScaleMapBuilder<T>;

// Warning: (ae-forgotten-export) The symbol "OptionBuilder" needs to be exported by the entry point lib.d.ts
//
// @public (undocumented)
export function createOptionBuilder<T extends Option_2<Fragment<any>>>(name: string, some: OptionBuilder<T>): ScaleEnumBuilder<T>;

// Warning: (ae-forgotten-export) The symbol "ResultOkBuilder" needs to be exported by the entry point lib.d.ts
// Warning: (ae-forgotten-export) The symbol "ResultErrBuilder" needs to be exported by the entry point lib.d.ts
//
// @public (undocumented)
export function createResultBuilder<T extends Result<Fragment<any>, Fragment<any>>>(name: string, ok: ResultOkBuilder<T>, err: ResultErrBuilder<T>): ScaleEnumBuilder<T>;

// Warning: (ae-forgotten-export) The symbol "SetEntryBuilder" needs to be exported by the entry point lib.d.ts
//
// @public (undocumented)
export function createSetBuilder<T extends Set<Fragment<any>>>(name: string, itemBuilder: SetEntryBuilder<T>): ScaleSetBuilder<T>;

// @public (undocumented)
export function createStructBuilder<T extends {
    [K in keyof T]: Fragment<any>;
}>(name: string, schema: StructBuilderSchema<T>): ScaleStructBuilder<T>;

// @public (undocumented)
export function createTupleBuilder<T extends Fragment<any>[]>(name: string, builders: FragmentBuilder<any>[]): ScaleTupleBuilder<T>;

// @public (undocumented)
export function createVecBuilder<T extends Fragment<any>[]>(name: string, itemBuilder: ArrayItemBuilder<T>): ScaleArrayBuilder<T>;

// @public (undocumented)
export class DecodeTrace {
    constructor(loc: string);
    // (undocumented)
    children: DecodeTrace[];
    // (undocumented)
    error?: unknown;
    // (undocumented)
    findRoot(): DecodeTrace;
    // (undocumented)
    input?: {
        offset: number;
    };
    // (undocumented)
    get isRoot(): boolean;
    loc: string[];
    // (undocumented)
    parent: DecodeTrace | null;
    // (undocumented)
    refineLoc(loc: string): this;
    // (undocumented)
    result?: {
        offset: number;
        value: unknown;
    };
    // (undocumented)
    setInput(offset: number): this;
    // (undocumented)
    setParent(trace: DecodeTrace): this;
}

// @public (undocumented)
export class DecodeTraceCollector {
    // (undocumented)
    decodeError(err: unknown): DecodeTrace;
    // (undocumented)
    decodeStart(loc: string, walker: Walker): void;
    // (undocumented)
    decodeSuccess(walker: Walker, decodedValue: unknown): null | DecodeTrace;
    // (undocumented)
    refineLoc(loc: string): void;
}

// @public
export class DynBuilder<T extends FragmentBuilder<any>> implements FragmentBuilder<FragmentOrBuilderValue<T>, FragmentOrBuilderUnwrapped<T>> {
    constructor(builderGetter: () => T);
    // (undocumented)
    decode(walker: Walker): Fragment<FragmentOrBuilderValue<T>, FragmentOrBuilderUnwrapped<T>>;
    // (undocumented)
    defineUnwrap(unwrappedValue: FragmentOrBuilderUnwrapped<T>): FragmentOrBuilderUnwrapped<T>;
    // (undocumented)
    fromBuffer(bytes: Uint8Array): Fragment<FragmentOrBuilderValue<T>, FragmentOrBuilderUnwrapped<T>>;
    // (undocumented)
    fromValue(value: FragmentOrBuilderValue<T>): Fragment<FragmentOrBuilderValue<T>, FragmentOrBuilderUnwrapped<T>>;
    getBuilder(): T;
    // (undocumented)
    wrap(unwrappedValue: FragmentOrBuilderUnwrapped<T>): Fragment<FragmentOrBuilderValue<T>, FragmentOrBuilderUnwrapped<T>>;
}

// @public (undocumented)
export function dynBuilder<T extends FragmentBuilder<any>>(dyn: () => T): DynBuilder<T>;

// @public (undocumented)
export const encodeAnyFragment: Encode<Fragment<any>>;

// @public (undocumented)
export type EnumBuilderSchema<Def extends EnumGenericDef> = (Def extends string ? [discriminant: number, tag: Def] : Def extends [infer T, infer V] ? V extends Fragment<infer FT, infer FU> ? [discriminant: number, tag: T, builder: FragmentBuilder<FT, FU>] : never : never)[];

// @public (undocumented)
export function formatWalkerStep(params: FormatWalkerStepParams): string;

// @public (undocumented)
export interface FormatWalkerStepParams {
    offsetEnd?: number;
    offsetStart: number;
    // (undocumented)
    walker: Walker;
}

// @public
export abstract class Fragment<Value, Unwrapped = Value> implements TrackValueInspectable {
    // (undocumented)
    [TrackValueInspect](): Unwrapped;
    constructor(value: typeof FRAGMENT_VALUE_EMPTY | Value, bytes: null | Uint8Array);
    // (undocumented)
    protected abstract __decode: Decode<Value>;
    // (undocumented)
    protected abstract __encode: Encode<Value>;
    protected abstract __name: string;
    // (undocumented)
    get bytes(): Uint8Array;
    // (undocumented)
    encode(walker: Walker): void;
    // (undocumented)
    get sizeHint(): number;
    abstract unwrap(): Unwrapped;
    // (undocumented)
    get value(): Value;
}

// @public
export interface FragmentBuilder<T, U = T> {
    decode: Decode<Fragment<T, U>>;
    defineUnwrap: (unwrappedValue: U) => U;
    fromBuffer: (bufferView: ArrayBufferView) => Fragment<T, U>;
    fromValue: (value: T) => Fragment<T, U>;
    wrap: (unwrappedValue: U) => Fragment<T, U>;
}

// @public (undocumented)
export type FragmentFromBuilder<T extends FragmentBuilder<any>> = T extends FragmentBuilder<infer V, infer U> ? Fragment<V, U> : never;

// @public (undocumented)
export type FragmentOrBuilderUnwrapped<T extends Fragment<any> | FragmentBuilder<any>> = T extends Fragment<any, infer U> ? U : T extends FragmentBuilder<any, infer U> ? U : never;

// @public (undocumented)
export type FragmentOrBuilderValue<T extends Fragment<any> | FragmentBuilder<any>> = T extends Fragment<infer V, any> ? V : T extends FragmentBuilder<infer V, any> ? V : never;

// @public (undocumented)
export type FragmentUnwrapFn<T, U> = (self: Fragment<T, U>) => U;

// @public (undocumented)
export type FragmentWrapFn<T, U> = (unwrapped: U) => T;

// @public
export function getCurrentTracker(): null | CodecTracker;

// @public (undocumented)
export const I128: FragmentBuilder<bigint, bigint>;

// @public (undocumented)
export const I16: FragmentBuilder<number, number>;

// @public (undocumented)
export const I32: FragmentBuilder<number, number>;

// @public (undocumented)
export const I64: FragmentBuilder<bigint, bigint>;

// @public (undocumented)
export const I8: FragmentBuilder<number, number>;

// @public (undocumented)
export function isTrackValueInspectable(value: unknown): value is TrackValueInspectable;

// @public
export class Logger implements CodecTracker {
    constructor(config?: LoggerConfig);
    // (undocumented)
    config?: LoggerConfig;
    // (undocumented)
    decode<T>(loc: string, walker: Walker, decode: Decode<T>): T;
    mount(): void;
    // (undocumented)
    refineDecodeLoc<T>(loc: string, decode: () => T): T;
    unmount(): void;
}

// @public (undocumented)
export interface LoggerConfig {
    logDecodeErrors?: boolean;
    logDecodeSuccesses?: boolean;
}

// @public (undocumented)
export type RefineDecodeLocFn = <T>(loc: string, headlessDecode: () => T) => T;

// Warning: (ae-forgotten-export) The symbol "UnwrapScaleArray" needs to be exported by the entry point lib.d.ts
//
// @public (undocumented)
export type ScaleArrayBuilder<T extends Fragment<any>[]> = FragmentBuilder<T, UnwrapScaleArray<T>>;

// @public (undocumented)
export type ScaleEnum = Enum<string | [string, Fragment<any>]>;

// @public (undocumented)
export type ScaleEnumBuilder<T extends Enum<any>> = FragmentBuilder<T, UnwrapScaleEnum<T>>;

// @public (undocumented)
export type ScaleMapBuilder<T extends Map<Fragment<any>, Fragment<any>>> = FragmentBuilder<T, UnwrapScaleMap<T>>;

// Warning: (ae-forgotten-export) The symbol "UnwrapScaleSet" needs to be exported by the entry point lib.d.ts
//
// @public (undocumented)
export type ScaleSetBuilder<T extends Set<Fragment<any>>> = FragmentBuilder<T, UnwrapScaleSet<T>>;

// @public
export type ScaleStructBuilder<T extends {
    [K in keyof T]: Fragment<any>;
}> = FragmentBuilder<T, UnwrapScaleStruct<T>>;

// Warning: (ae-forgotten-export) The symbol "UnwrapScaleTuple" needs to be exported by the entry point lib.d.ts
//
// @public (undocumented)
export type ScaleTupleBuilder<T> = FragmentBuilder<T, UnwrapScaleTuple<T>>;

// @public
export function setCurrentTracker(tracker: null | CodecTracker): void;

// @public (undocumented)
export const Str: FragmentBuilder<string, string>;

// @public (undocumented)
export type StructBuilderSchema<T> = [fieldName: keyof T & string, builder: FragmentBuilder<any>][];

// @public
export const trackDecode: TrackDecodeFn;

// @public (undocumented)
export type TrackDecodeFn = <T>(loc: string, walker: Walker, decode: Decode<T>) => T;

// @public
export const trackRefineDecodeLoc: RefineDecodeLocFn;

// @public
export const TrackValueInspect: unique symbol;

// @public
export interface TrackValueInspectable {
    // (undocumented)
    [TrackValueInspect]: () => any;
}

// @public (undocumented)
export function tryInspectValue(value: any): any;

// @public (undocumented)
export const U128: FragmentBuilder<bigint, bigint>;

// @public (undocumented)
export const U16: FragmentBuilder<number, number>;

// @public (undocumented)
export const U32: FragmentBuilder<number, number>;

// @public (undocumented)
export const U64: FragmentBuilder<bigint, bigint>;

// @public (undocumented)
export const U8: FragmentBuilder<number, number>;

// @public (undocumented)
export type UnwrapFragment<T> = T extends Fragment<any, infer U> ? U : T;

// @public (undocumented)
export type UnwrapScaleEnum<T extends ScaleEnum> = T extends Enum<infer Def> ? Enum<Def extends [infer Tag, infer V] ? (V extends Fragment<any, infer U> ? [Tag, U] : never) : Def> : never;

// @public (undocumented)
export type UnwrapScaleMap<T> = T extends Map<Fragment<any, infer K>, Fragment<any, infer V>> ? Map<UnwrapFragment<K>, UnwrapFragment<V>> : never;

// @public (undocumented)
export type UnwrapScaleStruct<T> = {
    [K in keyof T]: UnwrapFragment<T[K]>;
};

// @public (undocumented)
export const Void: FragmentBuilder<null, null>;


export * from "@scale-codec/core";

```
