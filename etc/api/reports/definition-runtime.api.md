## API Report File for "@scale-codec/definition-runtime"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Decode } from '@scale-codec/core';
import { Encode } from '@scale-codec/core';
import { Fmt } from 'fmt-subs';
import { RustOption } from '@scale-codec/core';
import { RustResult } from '@scale-codec/core';
import { VariantAny } from '@scale-codec/core';
import { VariantToFactoryArgs } from '@scale-codec/core';
import { Walker } from '@scale-codec/core';

// @public (undocumented)
export type ArrayCodecAndFactory<T extends Array<any>, U extends T> = Codec<U> & DefineOpaque<T, U>;

// @public (undocumented)
export type Bool = boolean;

// @public (undocumented)
export const Bool: Codec<boolean, boolean>;

// @public (undocumented)
export function buildDecodeTraceStepsFmt(trace: DecodeTrace, walker: Walker): Fmt;

// @public
export interface Codec<Encoded, Decoded = Encoded> {
    // (undocumented)
    decodeRaw: Decode<Decoded>;
    // (undocumented)
    encodeRaw: Encode<Encoded>;
    // (undocumented)
    fromBuffer: (src: ArrayBufferView) => Decoded;
    // (undocumented)
    toBuffer: (value: Encoded) => Uint8Array;
}

// @public (undocumented)
export type CodecAny = Codec<any, any>;

// @public
export interface CodecTracker {
    decode?: TrackDecodeFn;
    refineDecodeLoc?: RefineDecodeLocFn;
}

// @public (undocumented)
export type CodecValueDecoded<T extends Codec<any>> = T extends Codec<any, infer D> ? D : never;

// @public (undocumented)
export type CodecValueEncodable<T extends Codec<any>> = T extends Codec<infer E, any> ? E : never;

// @public (undocumented)
export type Compact = bigint;

// @public (undocumented)
export const Compact: Codec<bigint, bigint>;

// @public (undocumented)
export function createArrayCodec<T extends Array<any>, U extends T>(name: string, itemCodec: Codec<T extends Array<infer I> ? I : never>, len: number): ArrayCodecAndFactory<T, U>;

// @public (undocumented)
export function createArrayU8Codec(name: string, len: number): Codec<Uint8Array>;

// @public (undocumented)
export function createEnumCodec<T extends VariantAny>(name: string, schema: [discriminant: number, tag: string, codec?: Codec<any>][]): EnumCodecAndFactory<T>;

// @public (undocumented)
export function createMapCodec<T extends Map<any, any>, U extends T>(name: string, keyCodec: Codec<T extends Map<infer K, any> ? K : never>, valueCodec: Codec<T extends Map<any, infer V> ? V : never>): MapCodecAndFactory<T, U>;

// @public (undocumented)
export type CreateOpaqueEnumFn<V extends VariantAny> = (...args: VariantToFactoryArgs<V>) => V;

// @public (undocumented)
export function createOptionCodec<T extends RustOption<any>>(name: string, someCodec: Codec<T extends RustOption<infer V> ? V : never>): EnumCodecAndFactory<T>;

// @public (undocumented)
export function createResultCodec<T extends RustResult<any, any>>(name: string, okCodec: Codec<T extends RustResult<infer Ok, any> ? Ok : never>, errCodec: Codec<T extends RustResult<any, infer Err> ? Err : never>): EnumCodecAndFactory<T>;

// @public (undocumented)
export function createSetCodec<T extends Set<any>, U extends T>(name: string, itemCodec: Codec<T extends Set<infer V> ? V : never>): SetCodecAndFactory<T, U>;

// @public (undocumented)
export function createStructCodec<T, U extends T>(name: string, orderedCodecs: StructCodecsSchema<T>): StructCodecAndFactory<T, U>;

// @public (undocumented)
export function createTupleCodec<T extends Array<any>, U extends T>(name: string, codecs: TupleCodecs<T>): Codec<U> & DefineOpaque<T, U>;

// @public (undocumented)
export function createVecCodec<T extends any[], U extends T>(name: string, itemCodec: Codec<T extends (infer V)[] ? V : never>): ArrayCodecAndFactory<T, U>;

// @public (undocumented)
export class DecodeTrace {
    constructor(loc: string);
    // (undocumented)
    children: DecodeTrace[];
    // (undocumented)
    error?: unknown;
    // (undocumented)
    findRoot(): DecodeTrace;
    // (undocumented)
    input?: {
        offset: number;
    };
    // (undocumented)
    get isRoot(): boolean;
    loc: string[];
    // (undocumented)
    parent: DecodeTrace | null;
    // (undocumented)
    refineLoc(loc: string): this;
    // (undocumented)
    result?: {
        offset: number;
        value: unknown;
    };
    // (undocumented)
    setInput(offset: number): this;
    // (undocumented)
    setParent(trace: DecodeTrace): this;
}

// @public (undocumented)
export class DecodeTraceCollector {
    // (undocumented)
    decodeError(err: unknown): DecodeTrace;
    // (undocumented)
    decodeStart(loc: string, walker: Walker): void;
    // (undocumented)
    decodeSuccess(walker: Walker, decodedValue: unknown): null | DecodeTrace;
    // (undocumented)
    refineLoc(loc: string): void;
}

// @public
export type DefineOpaque<T, U extends T> = (actual: T) => U;

// @public (undocumented)
export function dynCodec<C extends CodecAny>(getter: () => C): Codec<CodecValueEncodable<C>, CodecValueDecoded<C>>;

// @public (undocumented)
export type EnumCodecAndFactory<T extends VariantAny> = Codec<T> & CreateOpaqueEnumFn<T>;

// @public (undocumented)
export function formatWalkerStep(params: FormatWalkerStepParams): string;

// @public (undocumented)
export interface FormatWalkerStepParams {
    offsetEnd?: number;
    offsetStart: number;
    // (undocumented)
    walker: Walker;
}

// @public
export function getCurrentTracker(): null | CodecTracker;

// @public (undocumented)
export type I128 = bigint;

// @public (undocumented)
export const I128: Codec<bigint, bigint>;

// @public (undocumented)
export type I16 = number;

// @public (undocumented)
export const I16: Codec<number, number>;

// @public (undocumented)
export type I32 = number;

// @public (undocumented)
export const I32: Codec<number, number>;

// @public (undocumented)
export type I64 = bigint;

// @public (undocumented)
export const I64: Codec<bigint, bigint>;

// @public (undocumented)
export type I8 = number;

// @public (undocumented)
export const I8: Codec<number, number>;

// @public (undocumented)
export function isTrackValueInspectable(value: unknown): value is TrackValueInspectable;

// @public
export class Logger implements CodecTracker {
    constructor(config?: LoggerConfig);
    // (undocumented)
    config?: LoggerConfig;
    // (undocumented)
    decode<T>(loc: string, walker: Walker, decode: Decode<T>): T;
    mount(): void;
    // (undocumented)
    refineDecodeLoc<T>(loc: string, decode: () => T): T;
    unmount(): void;
}

// @public (undocumented)
export interface LoggerConfig {
    logDecodeErrors?: boolean;
    logDecodeSuccesses?: boolean;
}

// @public (undocumented)
export type MapCodecAndFactory<T extends Map<any, any>, U extends T> = Codec<U> & DefineOpaque<T, U>;

// @public (undocumented)
export type RefineDecodeLocFn = <T>(loc: string, headlessDecode: () => T) => T;

// @public (undocumented)
export type SetCodecAndFactory<T extends Set<any>, U extends T> = Codec<U> & DefineOpaque<T, U>;

// @public
export function setCurrentTracker(tracker: null | CodecTracker): void;

// @public (undocumented)
export type Str = string;

// @public (undocumented)
export const Str: Codec<string, string>;

// @public (undocumented)
export type StructCodecAndFactory<T, U extends T> = Codec<U> & DefineOpaque<T, U>;

// @public (undocumented)
export type StructCodecsSchema<T> = {
    [K in keyof T]: [K, Codec<T[K]>];
}[keyof T][];

// @public (undocumented)
export function trackableCodec<E, D = E>(name: string, encode: Encode<E>, decode: Decode<D>): Codec<E, D>;

// @public
export const trackDecode: TrackDecodeFn;

// @public (undocumented)
export type TrackDecodeFn = <T>(loc: string, walker: Walker, decode: Decode<T>) => T;

// @public
export const trackRefineDecodeLoc: RefineDecodeLocFn;

// @public
export const TrackValueInspect: unique symbol;

// @public
export interface TrackValueInspectable {
    // (undocumented)
    [TrackValueInspect]: () => any;
}

// @public (undocumented)
export function tryInspectValue(value: any): any;

// @public (undocumented)
export type TupleCodecs<T extends any[]> = T extends [infer Head, ...infer Tail] ? [Codec<Head>, ...TupleCodecs<Tail>] : [];

// @public (undocumented)
export type U128 = bigint;

// @public (undocumented)
export const U128: Codec<bigint, bigint>;

// @public (undocumented)
export type U16 = number;

// @public (undocumented)
export const U16: Codec<number, number>;

// @public (undocumented)
export type U32 = number;

// @public (undocumented)
export const U32: Codec<number, number>;

// @public (undocumented)
export type U64 = bigint;

// @public (undocumented)
export const U64: Codec<bigint, bigint>;

// @public (undocumented)
export type U8 = number;

// @public (undocumented)
export const U8: Codec<number, number>;

// @public (undocumented)
export type VecU8 = Uint8Array;

// @public (undocumented)
export const VecU8: Codec<Uint8Array, Uint8Array>;

// @public (undocumented)
export type Void = null;

// @public (undocumented)
export const Void: Codec<null, null>;


export * from "@scale-codec/core";

```
